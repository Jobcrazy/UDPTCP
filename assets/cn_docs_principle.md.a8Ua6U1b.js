import{_ as a,c as e,o as t,a2 as r}from"./chunks/framework.BJ0zSiM-.js";const _=JSON.parse('{"title":"NetGuard 工作原理","description":"","frontmatter":{},"headers":[],"relativePath":"cn/docs/principle.md","filePath":"cn/docs/principle.md"}'),l={name:"cn/docs/principle.md"},i=r('<h1 id="netguard-工作原理" tabindex="-1">NetGuard 工作原理 <a class="header-anchor" href="#netguard-工作原理" aria-label="Permalink to &quot;NetGuard 工作原理&quot;">​</a></h1><p>一般来说，发起 DDoS 的攻击者会控制大量的傀儡机(俗称肉机或肉机)，对目标服务器发起不同类型的攻击。</p><p>不论是哪种攻击，它们的目的都是阻碍正常用户与服务器之间的通讯。</p><p>我们将讨论两种常见的攻击，以及 NetGuard 的防范措施。</p><h2 id="ddos-攻击的类型" tabindex="-1">DDoS 攻击的类型 <a class="header-anchor" href="#ddos-攻击的类型" aria-label="Permalink to &quot;DDoS 攻击的类型&quot;">​</a></h2><h3 id="udp-放大攻击" tabindex="-1">UDP 放大攻击 <a class="header-anchor" href="#udp-放大攻击" aria-label="Permalink to &quot;UDP 放大攻击&quot;">​</a></h3><p>收发 UDP 数据无需建立连接，且来源地址可以伪造，使得 UDP 成为网络攻击最常用的协议。</p><p>攻击者伪造为受害者服务器的地址，向拥有较大带宽、且协议设计有缺陷的网络服务器(例如 DNS 服务器等)发起大量的查询请求，而这些网络服务器将会把查询结果发到受害者的服务器。查询结果的大小往往是查询请求的很多倍，所以攻击者可以使用相对较小的带宽，发起较大规模的攻击。</p><p>这些攻击导致的带宽占用常常高达几十 Gbps 到几百 Gbps，即使受害者的服务器没有开启任何端口，它所处的机房依然会收到这些攻击流量。如果机房的带宽不足，那么整个机房的服务器都会被影响。所以，机房往往会限制每台服务器或每个 IP 的最大防御值，攻击达到防御值后，机房会切断受害者服务器的网络连接，直到攻击停止。</p><h3 id="tcp-连接攻击" tabindex="-1">TCP 连接攻击 <a class="header-anchor" href="#tcp-连接攻击" aria-label="Permalink to &quot;TCP 连接攻击&quot;">​</a></h3><p>收发 TCP 数据必须先连接，且来源地址不可伪造。即使如此，针对 TCP 的攻击也是很常见的。</p><p>每个 TCP 连接都会消耗掉服务器的 CPU/内存/网络资源，所以每台服务器能同时处理的 TCP 连接是有限的。攻击者控制大量傀儡机，向受害者的服务器发起 TCP 连接。有时候，他们会保持这些 TCP 连接不断开，但也不发送任何数据；有时候，他们会快速建立连接并断开连接。</p><p>不论是哪种方式，都会消耗掉有限的服务器资源。当服务器资源被耗尽，正常用户也将无法与服务器建立连接。</p><h2 id="netguard-怎么做" tabindex="-1">NetGuard 怎么做 <a class="header-anchor" href="#netguard-怎么做" aria-label="Permalink to &quot;NetGuard 怎么做&quot;">​</a></h2><h3 id="更改数据路径" tabindex="-1">更改数据路径 <a class="header-anchor" href="#更改数据路径" aria-label="Permalink to &quot;更改数据路径&quot;">​</a></h3><p>接入 NetGuard 的 SDK 后，App 与服务器之间的数据流动如下：</p><ol><li>NetGuard SDK 启动后，会绑定到 127 开头的回环 IP 地址</li><li>客户端直接连接上述的回环 IP 地址，而不是真实业务服务器</li><li>NetGuard SDK 会把收到的数据发送到数据转发服务器</li><li>数据转发服务器把收到的数据转发到用户保活服务器</li><li>用户保活服务器把收到的数据转发到业务服务器</li><li>用户保活服务器接收业务服务器的数据并转发给数据转发服务器</li><li>数据转发服务器把收到的业务数据转发给 NetGuard SDK</li><li>NetGuard SDK 把接收到的业务数据转发给客户端 App</li></ol><div class="tip custom-block"><p class="custom-block-title">整个流程大致如下</p><p>客户端 App &lt;--&gt; NetGuard SDK &lt;--&gt; 数据转发服务器(网关) &lt;--&gt; 用户保活服务器(盾机) &lt;--&gt; 开发者服务器</p></div><h3 id="巧用数学技巧" tabindex="-1">巧用数学技巧 <a class="header-anchor" href="#巧用数学技巧" aria-label="Permalink to &quot;巧用数学技巧&quot;">​</a></h3><p>攻击者在攻击目标服务器之前，必须要找到目标服务器的 IP 地址，才能发起攻击。所以，NetGuard 做的第一件事，就是隐藏真实服务器的 IP 地址。</p><p>在 NetGuard 的用户后台，可以添加最多 30 个数据转发服务器 IP 地址，开发者需要把数据转发服务端部署到这些 IP 地址。当最终用户启动带有 NetGuard SDK 的 App 后，SDK 会从 NetGuard 的服务器获取到 4 个 IP 地址。通过这样的数学办法，开发者可以创建高达 27405 个不同的 IP 地址组合。</p><p>攻击者分析 App 的时候，也会得到其中一组 IP 地址。当他设法使这这一组里的 IP 地址全部掉线之后，其他用户根本不会受到任何影响，因为其他用户被分配的 4 个 IP 地址跟他是不一样的。所以受影响的用户数只占全部用户数的<sup>1</sup>/<sub>27405</sub></p><h3 id="保持用户连接" tabindex="-1">保持用户连接 <a class="header-anchor" href="#保持用户连接" aria-label="Permalink to &quot;保持用户连接&quot;">​</a></h3><p>NetGuard 基于 TCP 实现了一套自己的数据收发协议。当用户因为各种原因与服务器断开连接，NetGuard 会立刻从上述的 4 个 IP 地址里选择另一个进行连接，并把数据进行断点续传。这一切对于开发者和用户都是透明的，只要接入 NetGuard SDK 和服务器，他们不需要做任何额外的事情，只用按以前那样正常收发数据就可以了。</p><h3 id="限制-tcp-连接" tabindex="-1">限制 TCP 连接 <a class="header-anchor" href="#限制-tcp-连接" aria-label="Permalink to &quot;限制 TCP 连接&quot;">​</a></h3><p>NetGuard 的服务端可按需限制每个 IP(甚至每台设备)的 TCP 并发连接数及连接频率，确保不会瞬间有大量的无效 TCP 连接到达 App 服务器。<strong>请注意</strong>：自建服务器只能限制 IP 和设备的并发连接数，无法限制连接频率。</p><h2 id="下一步做什么" tabindex="-1">下一步做什么 <a class="header-anchor" href="#下一步做什么" aria-label="Permalink to &quot;下一步做什么&quot;">​</a></h2><ol><li>如果你想节省成本，或不想了解太多技术细节，请加入<a href="./shared.html">共同防御计划</a></li><li>如果你想自己搭建 NetGuard 服务端，请阅读<a href="./selfhosted.html">自建服务器</a>章节</li><li>如果你已加入<a href="./shared.html">共同防御计划</a>或已<a href="./selfhosted.html">自建服务器</a>，即可<a href="./integrate.html">接入 NetGuard SDK</a></li></ol>',28),d=[i];function o(p,h,s,n,c,u){return t(),e("div",null,d)}const b=a(l,[["render",o]]);export{_ as __pageData,b as default};
