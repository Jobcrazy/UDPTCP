import{_ as e,c as t,o as a,a2 as s}from"./chunks/framework.BJ0zSiM-.js";const m=JSON.parse('{"title":"How NetGuard Works","description":"","frontmatter":{},"headers":[],"relativePath":"docs/principle.md","filePath":"docs/principle.md"}'),r={name:"docs/principle.md"},o=s('<h1 id="how-netguard-works" tabindex="-1">How NetGuard Works <a class="header-anchor" href="#how-netguard-works" aria-label="Permalink to &quot;How NetGuard Works&quot;">​</a></h1><p>Typically, DDoS attackers control numerous botnets (often called &quot;zombie&quot;) to launch various attacks on the target server.</p><p>Regardless of the attack type, the goal is to disrupt communication between legitimate users and the app server.</p><p>We will discuss two common types of attacks and how NetGuard counters them.</p><h2 id="types-of-ddos-attacks" tabindex="-1">Types of DDoS Attacks <a class="header-anchor" href="#types-of-ddos-attacks" aria-label="Permalink to &quot;Types of DDoS Attacks&quot;">​</a></h2><h3 id="udp-amplification-attack" tabindex="-1">UDP Amplification Attack <a class="header-anchor" href="#udp-amplification-attack" aria-label="Permalink to &quot;UDP Amplification Attack&quot;">​</a></h3><p>UDP is commonly used in network attacks because it doesn’t require a connection to send or receive data and can spoof source addresses.</p><p>Attackers spoof the victim server&#39;s address and send numerous queries to high-bandwidth servers with protocol flaws (e.g., DNS servers). These servers then send the query results to the victim’s server. The response size is often much larger than the request, allowing attackers to use relatively small bandwidth to launch large-scale attacks.</p><p>These attacks can consume bandwidth from tens of Gbps to hundreds of Gbps. Even if the victim’s server doesn’t have open ports, the data floods into the data center, potentially affecting all servers in the facility. To handle this, data centers often limit the defense capacity per server or IP, disconnecting the victim server once the limit is reached, until the attack subsides.</p><h3 id="tcp-connection-attack" tabindex="-1">TCP Connection Attack <a class="header-anchor" href="#tcp-connection-attack" aria-label="Permalink to &quot;TCP Connection Attack&quot;">​</a></h3><p>TCP requires a connection to send and receive data, and source addresses cannot be spoofed. Despite this, TCP attacks are still common.</p><p>Each TCP connection consumes CPU, memory, and network resources on the server, so the number of simultaneous connections a server can handle is limited. Attackers control numerous botnets to initiate TCP connections with the victim’s server. Sometimes, they keep these connections open without sending data; other times, they rapidly open and close connections.</p><p>In either case, this exhausts the server&#39;s resources, preventing legitimate users from connecting.</p><h2 id="how-netguard-works-1" tabindex="-1">How NetGuard Works <a class="header-anchor" href="#how-netguard-works-1" aria-label="Permalink to &quot;How NetGuard Works&quot;">​</a></h2><h3 id="changing-the-data-path" tabindex="-1">Changing the Data Path <a class="header-anchor" href="#changing-the-data-path" aria-label="Permalink to &quot;Changing the Data Path&quot;">​</a></h3><p>After integrating the NetGuard SDK, the data flow between your app and server is as follows:</p><ol><li>The SDK starts and binds to a loopback IP address (e.g. 127.0.0.1).</li><li>The client connects directly to this loopback IP, not the app server.</li><li>The SDK relays the data to the forwarding server.</li><li>The forwarding server relays the data to the persistence server.</li><li>The persistence server forwards the data to the app server.</li><li>The persistence server receives data from the app server and sends it back to the forwarding server.</li><li>The forwarding server sends the data to the NetGuard SDK.</li><li>The SDK forwards the data to the client app.</li></ol><div class="tip custom-block"><p class="custom-block-title">The Process Overview</p><p>Client App &lt;--&gt; NetGuard SDK &lt;--&gt; Forwarding Server (Gateway) &lt;--&gt; Persistence Server (Shield) &lt;--&gt; Developer&#39;s Server</p></div><h3 id="mathematical-techniques" tabindex="-1">Mathematical Techniques <a class="header-anchor" href="#mathematical-techniques" aria-label="Permalink to &quot;Mathematical Techniques&quot;">​</a></h3><p>Before attacking the target server, attackers must identify its IP address. Thus, the first step of NetGuard is to hide the real server IP.</p><p>In the NetGuard dashboard, you can add up to 30 forwarding server IP addresses. Developers need to deploy the forwarding server program on these IP addresses. When users start the app with the NetGuard SDK, the SDK fetches 4 IP addresses from the Defender&#39;s servers. This mathematical approach allows developers to create up to 27,405 unique IP address combinations.</p><p>When attackers analyze the app, they only get one set of these IP addresses. Even if they manage to take down all IP addresses in this set, other users remain unaffected because they are assigned a different set of 4 IP addresses. Therefore, the affected user count is only <sup>1</sup>/<sub>27,405</sub> of the total.</p><h3 id="maintaining-user-sessions" tabindex="-1">Maintaining User Sessions <a class="header-anchor" href="#maintaining-user-sessions" aria-label="Permalink to &quot;Maintaining User Sessions&quot;">​</a></h3><p>NetGuard uses a customized protocol based on TCP. When a user disconnects from the server for any reason, NetGuard instantly selects another IP address from the 4 provided and continues data transmission from where it left off. This process is transparent to both developers and users; once the NetGuard SDK and servers are integrated, no additional actions are needed. Users can continue to send and receive data as usual.</p><h3 id="limiting-tcp-connections" tabindex="-1">Limiting TCP Connections <a class="header-anchor" href="#limiting-tcp-connections" aria-label="Permalink to &quot;Limiting TCP Connections&quot;">​</a></h3><p>NetGuard&#39;s server can limit the number of concurrent TCP connections and connection frequency per IP address (or even per device) as needed, ensuring that a large volume of invalid TCP connections does not overwhelm the app server. <strong>Note</strong>: Self-hosted servers can only limit concurrent connections per IP and device, not connection frequency.</p><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">​</a></h2><ol><li>To save costs or avoid technical details, join our <a href="./shared.html">Shared Defense Plan</a>.</li><li>To set up your own NetGuard server, read the <a href="./selfhosted.html">Self-Hosted Server</a> section.</li><li>If you’ve joined the <a href="./shared.html">Shared Defense Plan</a> or <a href="./selfhosted.html">Set up Your Own Server</a>, integrate the NetGuard SDK.</li></ol>',28),n=[o];function i(c,d,h,l,p,u){return a(),t("div",null,n)}const v=e(r,[["render",i]]);export{m as __pageData,v as default};
